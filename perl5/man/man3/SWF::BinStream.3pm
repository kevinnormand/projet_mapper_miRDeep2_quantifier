.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SWF::BinStream 3pm"
.TH SWF::BinStream 3pm "2004-09-14" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SWF::BinStream \- Read and write binary stream.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SWF::BinStream;
\&
\&  $read_stream = SWF::BinStream::Read\->new($binary_data, \e&adddata);
\&  $byte = $read_stream\->get_UI8;
\&  $signedbyte = $read_stream\->get_SI8;
\&  $string = $read_stream\->get_string($length);
\&  $bits = $read_stream\->get_bits($bitlength);
\&  ....
\&
\&  sub adddata {
\&      if ($nextdata) {
\&          shift\->add_stream($nextdata);
\&      } else {
\&          die "The stream ran short ";
\&      }
\&  }
\&
\&  $write_stream = SWF::BinStream::Write\->new;
\&  $write_stream\->set_UI8($byte);
\&  $write_stream\->set_SI8($signedbyte);
\&  $write_stream\->set_string($string);
\&  $write_stream\->set_bits($bits, $bitlength);
\&  $binary_data=$write_stream\->flush_stream;
\&  ....
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fISWF::BinStream\fR module provides a binary byte and bit data stream.
It can handle bit-compressed data such as \s-1SWF\s0 file.
.SS "SWF::BinStream::Read"
.IX Subsection "SWF::BinStream::Read"
Provides a read stream. Add the binary data to the stream, and you 
get byte and bit data. The stream calls a user subroutine when the 
stream data runs short.
\&\fIget_UI16\fR, \fIget_SI16\fR, \fIget_UI32\fR, and \fIget_SI32\fR get a number
in \s-1VAX\s0 byte order from the stream.
\&\fIget_bits\fR and \fIget_sbits\fR get the bits from \s-1MSB\s0 to \s-1LSB.
\&\s0\fIget_UI*\fR, \fIget_SI*\fR, and \fIget_string\fR skip the remaining bits in 
the current byte and read data from the next byte.
If you want to skip remaining bits manually, use \fIflush_bits\fR.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "SWF::BinStream::Read\->new( [ $initialdata, \e&callback_in_short, $version ] )" 4
.el .IP "SWF::BinStream::Read\->new( [ \f(CW$initialdata\fR, \e&callback_in_short, \f(CW$version\fR ] )" 4
.IX Item "SWF::BinStream::Read->new( [ $initialdata, &callback_in_short, $version ] )"
Creates a read stream. It takes three optional arguments. The first arg 
is a binary string to set as initial data of the stream. The second is
a reference of a subroutine which is called when the stream data runs
short.  The subroutine is called with two \s-1ARGS,\s0 the first is \fI\f(CI$stream\fI\fR
itself, and the second is how many bytes wanted.  
The third arg is \s-1SWF\s0 version number.  Default is 5.  It is necessary to
set proper version because some \s-1SWF\s0 tags change their structure by the 
version number.
.ie n .IP "$stream\->Version" 4
.el .IP "\f(CW$stream\fR\->Version" 4
.IX Item "$stream->Version"
returns \s-1SWF\s0 version number of the stream.
.ie n .IP "$stream\->add_codec( $codec_name )" 4
.el .IP "\f(CW$stream\fR\->add_codec( \f(CW$codec_name\fR )" 4
.IX Item "$stream->add_codec( $codec_name )"
Adds stream decoder.
Decoder 'Zlib' is only available now.
.ie n .IP "$stream\->add_stream( $binary_data )" 4
.el .IP "\f(CW$stream\fR\->add_stream( \f(CW$binary_data\fR )" 4
.IX Item "$stream->add_stream( $binary_data )"
Adds binary data to the stream.
.ie n .IP "$stream\->Length" 4
.el .IP "\f(CW$stream\fR\->Length" 4
.IX Item "$stream->Length"
Returns how many bytes remain in the stream.
.ie n .IP "$stream\->tell" 4
.el .IP "\f(CW$stream\fR\->tell" 4
.IX Item "$stream->tell"
Returns how many bytes have been read from the stream.
.ie n .IP "$stream\->get_string( $num )" 4
.el .IP "\f(CW$stream\fR\->get_string( \f(CW$num\fR )" 4
.IX Item "$stream->get_string( $num )"
Returns \f(CW$num\fR bytes as a string.
.ie n .IP "$stream\->get_UI8" 4
.el .IP "\f(CW$stream\fR\->get_UI8" 4
.IX Item "$stream->get_UI8"
Returns an unsigned byte number.
.ie n .IP "$stream\->get_SI8" 4
.el .IP "\f(CW$stream\fR\->get_SI8" 4
.IX Item "$stream->get_SI8"
Returns a signed byte number.
.ie n .IP "$stream\->get_UI16" 4
.el .IP "\f(CW$stream\fR\->get_UI16" 4
.IX Item "$stream->get_UI16"
Returns an unsigned word (2 bytes) number.
.ie n .IP "$stream\->get_SI16" 4
.el .IP "\f(CW$stream\fR\->get_SI16" 4
.IX Item "$stream->get_SI16"
Returns a signed word (2 bytes) number.
.ie n .IP "$stream\->get_UI32" 4
.el .IP "\f(CW$stream\fR\->get_UI32" 4
.IX Item "$stream->get_UI32"
Returns an unsigned double word (4 bytes) number.
.ie n .IP "$stream\->get_SI32" 4
.el .IP "\f(CW$stream\fR\->get_SI32" 4
.IX Item "$stream->get_SI32"
Returns a signed double word (4 bytes) number.
.ie n .IP "$stream\->get_bits( $num )" 4
.el .IP "\f(CW$stream\fR\->get_bits( \f(CW$num\fR )" 4
.IX Item "$stream->get_bits( $num )"
Returns the \f(CW$num\fR bit unsigned number.
.ie n .IP "$stream\->get_sbits( $num )" 4
.el .IP "\f(CW$stream\fR\->get_sbits( \f(CW$num\fR )" 4
.IX Item "$stream->get_sbits( $num )"
Returns the \f(CW$num\fR bit signed number.
.ie n .IP "$stream\->lookahead_string( $offset, $num )" 4
.el .IP "\f(CW$stream\fR\->lookahead_string( \f(CW$offset\fR, \f(CW$num\fR )" 4
.IX Item "$stream->lookahead_string( $offset, $num )"
.PD 0
.ie n .IP "$stream\->lookahead_UI8( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_UI8( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_UI8( $offset )"
.ie n .IP "$stream\->lookahead_SI8( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_SI8( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_SI8( $offset )"
.ie n .IP "$stream\->lookahead_UI16( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_UI16( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_UI16( $offset )"
.ie n .IP "$stream\->lookahead_SI16( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_SI16( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_SI16( $offset )"
.ie n .IP "$stream\->lookahead_UI32( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_UI32( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_UI32( $offset )"
.ie n .IP "$stream\->lookahead_SI32( $offset )" 4
.el .IP "\f(CW$stream\fR\->lookahead_SI32( \f(CW$offset\fR )" 4
.IX Item "$stream->lookahead_SI32( $offset )"
.PD
Returns the stream data \f(CW$offset\fR bytes ahead of the current read point.
The read pointer does not move.
.ie n .IP "$stream\->flush_bits" 4
.el .IP "\f(CW$stream\fR\->flush_bits" 4
.IX Item "$stream->flush_bits"
Skips the rest bits in the byte and aligned read pointer to the next byte.
It does not anything when the read pointer already byte-aligned.
.SS "SWF::BinStream::Write"
.IX Subsection "SWF::BinStream::Write"
Provides a write stream. Write byte and bit data, then get the stream
data as binary string using \fIflush_stream\fR. \fIautoflush\fR requests to
the stream to automatically flush the stream and call a user subroutine.
\&\fIset_UI16\fR, \fIset_SI16\fR, \fIset_UI32\fR, and \fIset_SI32\fR write a number in 
\&\s-1VAX\s0 byte order to the stream.
\&\fIset_bits\fR and \fIset_sbits\fR write the bits from \s-1MSB\s0 to \s-1LSB.
\&\s0\fIset_UI*\fR, \fIset_SI*\fR, and \fIset_string\fR set the rest bits in the last 
byte to 0 and write data to the next byte boundary.
If you want to write bit data and align the write pointer to byte boundary,
use \fIflush_bits\fR.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "SWF::BinStream::Write\->new( [$version] )" 4
.IX Item "SWF::BinStream::Write->new( [$version] )"
Creates a write stream.
One optional argument is \s-1SWF\s0 version number.  Default is 5.
It is necessary to set proper version because some \s-1SWF\s0 tags change 
their structure by the version number.
.ie n .IP "$stream\->Version( [$version] )" 4
.el .IP "\f(CW$stream\fR\->Version( [$version] )" 4
.IX Item "$stream->Version( [$version] )"
returns \s-1SWF\s0 version number of the stream.
You can change the version before you write data to the stream.
.ie n .IP "$stream\->add_codec( $codec_name )" 4
.el .IP "\f(CW$stream\fR\->add_codec( \f(CW$codec_name\fR )" 4
.IX Item "$stream->add_codec( $codec_name )"
Adds stream encoder.
Encoder 'Zlib' is only available now.
.ie n .IP "$stream\->autoflush( $size, \e&callback_when_flush )" 4
.el .IP "\f(CW$stream\fR\->autoflush( \f(CW$size\fR, \e&callback_when_flush )" 4
.IX Item "$stream->autoflush( $size, &callback_when_flush )"
Requests to the stream to automatically flush the stream and call sub
with the stream data when the stream size becomes larger than \fI\f(CI$size\fI\fR bytes.
.ie n .IP "$stream\->flush_stream( [$size] )" 4
.el .IP "\f(CW$stream\fR\->flush_stream( [$size] )" 4
.IX Item "$stream->flush_stream( [$size] )"
Flushes the stream and returns the stream data. Call with \fI\f(CI$size\fI\fR,
it returns \fI\f(CI$size\fI\fR bytes from the stream. When call without arg or
with larger \fI\f(CI$size\fI\fR than the stream data size, it returns all data
including the last bit data ( by calling \fIflush_bits\fR internally).
.ie n .IP "$stream\->flush_bits" 4
.el .IP "\f(CW$stream\fR\->flush_bits" 4
.IX Item "$stream->flush_bits"
Sets the rest bits in the last byte to 0, and aligns write pointer 
to the next byte boundary.
.ie n .IP "$stream\->Length" 4
.el .IP "\f(CW$stream\fR\->Length" 4
.IX Item "$stream->Length"
Returns how many bytes remain in the stream.
.ie n .IP "$stream\->tell" 4
.el .IP "\f(CW$stream\fR\->tell" 4
.IX Item "$stream->tell"
Returns how many bytes have written.
.ie n .IP "$stream\->mark( [$key, [$obj]] )" 4
.el .IP "\f(CW$stream\fR\->mark( [$key, [$obj]] )" 4
.IX Item "$stream->mark( [$key, [$obj]] )"
Keeps current \fItell\fR number with \f(CW$key\fR and \f(CW$obj\fR.
When called without \f(CW$obj\fR, it returns \fItell\fR number associated
with \f(CW$key\fR and a list of \fItell\fR number and object in scalar and 
list context, respectively.
When called without any parameter, it returns mark list
( \s-1KEY1,\s0 [ \s-1TELL_NUMBER1, OBJ1 \s0], \s-1KEY2,\s0 [...).
.ie n .IP "$stream\->sub_stream" 4
.el .IP "\f(CW$stream\fR\->sub_stream" 4
.IX Item "$stream->sub_stream"
Creates temporaly sub stream. When \fIflush_stream\fR the sub stream, 
it's data and marks are written to the parent stream and the sub 
stream is freed.
.Sp
Ex. write various length of data following it's length.
.Sp
.Vb 4
\&  $sub_stream=$parent_stream\->sub_stream;
\&  write_data($sub_stream);
\&  $parent_stream\->set_UI32($sub_stream\->Length);
\&  $sub_stream\->flush_stream;
.Ve
.ie n .IP "$stream\->set_string( $str )" 4
.el .IP "\f(CW$stream\fR\->set_string( \f(CW$str\fR )" 4
.IX Item "$stream->set_string( $str )"
Writes string to the stream.
.ie n .IP "$stream\->set_UI8( $num )" 4
.el .IP "\f(CW$stream\fR\->set_UI8( \f(CW$num\fR )" 4
.IX Item "$stream->set_UI8( $num )"
Writes \fI\f(CI$num\fI\fR as an unsigned byte.
.ie n .IP "$stream\->set_SI8( $num )" 4
.el .IP "\f(CW$stream\fR\->set_SI8( \f(CW$num\fR )" 4
.IX Item "$stream->set_SI8( $num )"
Writes \fI\f(CI$num\fI\fR as a signed byte.
.ie n .IP "$stream\->set_UI16( $num )" 4
.el .IP "\f(CW$stream\fR\->set_UI16( \f(CW$num\fR )" 4
.IX Item "$stream->set_UI16( $num )"
Writes \fI\f(CI$num\fI\fR as an unsigned word.
.ie n .IP "$stream\->set_SI16( $num )" 4
.el .IP "\f(CW$stream\fR\->set_SI16( \f(CW$num\fR )" 4
.IX Item "$stream->set_SI16( $num )"
Writes \fI\f(CI$num\fI\fR as a signed word.
.ie n .IP "$stream\->set_UI32( $num )" 4
.el .IP "\f(CW$stream\fR\->set_UI32( \f(CW$num\fR )" 4
.IX Item "$stream->set_UI32( $num )"
Writes \fI\f(CI$num\fI\fR as an unsigned double word.
.ie n .IP "$stream\->set_SI32( $num )" 4
.el .IP "\f(CW$stream\fR\->set_SI32( \f(CW$num\fR )" 4
.IX Item "$stream->set_SI32( $num )"
Writes \fI\f(CI$num\fI\fR as an unsigned double word.
.ie n .IP "$stream\->set_bits( $num, $nbits )" 4
.el .IP "\f(CW$stream\fR\->set_bits( \f(CW$num\fR, \f(CW$nbits\fR )" 4
.IX Item "$stream->set_bits( $num, $nbits )"
Write \fI\f(CI$num\fI\fR as \fI\f(CI$nbits\fI\fR length unsigned bit data.
.ie n .IP "$stream\->set_sbits( $num, $nbits )" 4
.el .IP "\f(CW$stream\fR\->set_sbits( \f(CW$num\fR, \f(CW$nbits\fR )" 4
.IX Item "$stream->set_sbits( $num, $nbits )"
Write \fI\f(CI$num\fI\fR as \fI\f(CI$nbits\fI\fR length signed bit data.
.ie n .IP "$stream\->set_bits_list( $nbitsbit, @list )" 4
.el .IP "\f(CW$stream\fR\->set_bits_list( \f(CW$nbitsbit\fR, \f(CW@list\fR )" 4
.IX Item "$stream->set_bits_list( $nbitsbit, @list )"
Makes \fI\f(CI@list\fI\fR as unsigned bit data list.
It writes the maximal bit length of each \fI\f(CI@list\fI\fR (\fInbits\fR) as
\&\fI\f(CI$nbitsbit\fI\fR length unsigned bit data, and then writes each \fI\f(CI@list\fI\fR
number as \fInbits\fR length unsigned bit data.
.ie n .IP "$stream\->set_sbits_list( $nbitsbit, @list )" 4
.el .IP "\f(CW$stream\fR\->set_sbits_list( \f(CW$nbitsbit\fR, \f(CW@list\fR )" 4
.IX Item "$stream->set_sbits_list( $nbitsbit, @list )"
Makes \fI\f(CI@list\fI\fR as signed bit data list.
It writes the maximal bit length of each \fI\f(CI@list\fI\fR (\fInbits\fR) as
\&\fI\f(CI$nbitsbit\fI\fR length unsigned bit data, and then writes each \fI\f(CI@list\fI\fR
number as \fInbits\fR\-length signed bit data.
.SS "\s-1UTILITY FUNCTIONS\s0"
.IX Subsection "UTILITY FUNCTIONS"
.ie n .IP "&SWF::BinStream::Write::get_maxbits_of_bits_list( @list )" 4
.el .IP "&SWF::BinStream::Write::get_maxbits_of_bits_list( \f(CW@list\fR )" 4
.IX Item "&SWF::BinStream::Write::get_maxbits_of_bits_list( @list )"
.PD 0
.ie n .IP "&SWF::BinStream::Write::get_maxbits_of_sbits_list( @list )" 4
.el .IP "&SWF::BinStream::Write::get_maxbits_of_sbits_list( \f(CW@list\fR )" 4
.IX Item "&SWF::BinStream::Write::get_maxbits_of_sbits_list( @list )"
.PD
Gets the necessary and sufficient bit length to represent the values of 
\&\fI\f(CI@list\fI\fR.  \-_bits_list is for unsigned values, and \-_sbits_list is for signed.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000 Yasuhiro Sasama (ySas), <ysas@nmt.ne.jp>
.PP
This library is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
