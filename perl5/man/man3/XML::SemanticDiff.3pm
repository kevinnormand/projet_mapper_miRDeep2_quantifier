.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::SemanticDiff 3"
.TH XML::SemanticDiff 3 "2016-05-09" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::SemanticDiff \- Perl extension for comparing XML documents.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::SemanticDiff;
\&  my $diff = XML::SemanticDiff\->new();
\&
\&  foreach my $change ($diff\->compare($file, $file2)) {
\&      print "$change\->{message} in context $change\->{context}\en";
\&  }
\&
\&  # or, if you want line numbers:
\&
\&  my $diff = XML::SemanticDiff\->new(keeplinenums => 1);
\&
\&  foreach my $change ($diff\->compare($file, $file2)) {
\&      print "$change\->{message} (between lines $change\->{startline} and $change\->{endline})\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::SematicDiff provides a way to compare the contents and structure of two \s-1XML\s0 documents. By default, it returns a list of
hashrefs where each hashref describes a single difference between the two docs.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$obj\->new([%options])"
.el .SS "\f(CW$obj\fP\->new([%options])"
.IX Subsection "$obj->new([%options])"
Ye olde object constructor.
.PP
The \fInew()\fR method recognizes the following options:
.IP "\(bu" 4
keeplinenums
.Sp
When this option is enabled XML::SemanticDiff will add the 'startline' and 'endline' properties (containing the line numbers
for the reported element's start tag and end tag) to each warning. For attribute events these numbers reflect the start and
end tags of the element which contains that attribute.
.IP "\(bu" 4
keepdata
.Sp
When this option is enabled XML::SemanticDiff will add the 'old_value' and 'new_value' properties to each warning. These
properties contain, surprisingly, the old and new values for the element or attribute being reported.
.Sp
In the case of missing elements or attributes (those in the first document, not in the second) only the 'old_value' property
will be defined. Similarly, in the case of rogue elements or attributes (those in the second document but not in the
first) only the 'new_value' property will be defined.
.Sp
Note that using this option will greatly increase the amount of memory used by your application.
.IP "\(bu" 4
diffhandler
.Sp
Taking a blessed object as it's sole argument, this option provides a way to hook the basic semantic diff engine into your own
custom handler class.
.Sp
Please see the section on '\s-1CUSTOM HANDLERS\s0' below.
.IP "\(bu" 4
ignorexpath
.Sp
This option takes array of strings as argument. Strings are interpreted as simple xpath expressions. Nodes matching these expressions are ignored during comparison. All xpath expressions should be absolute (start with '/').
.Sp
Current implementation ignores namespaces during comparison.
.ie n .SS "@results = $differ\->compare($xml1, $xml2)"
.el .SS "\f(CW@results\fP = \f(CW$differ\fP\->compare($xml1, \f(CW$xml2\fP)"
.IX Subsection "@results = $differ->compare($xml1, $xml2)"
Compares the XMLs \f(CW$xml1\fR and \f(CW$xml2\fR . \f(CW$xml1\fR and \f(CW$xml2\fR can be:
.IP "\(bu" 4
filenames
.Sp
This will be considered if it is a string that does not contain newlines and 
exists in the filesystem.
.IP "\(bu" 4
the \s-1XML\s0 text itself.
.Sp
This will be considered if it's any kind of string.
.IP "\(bu" 4
the results of \fIread_xml()\fR. (see below)
.Sp
This will be considered if it's a hash reference.
.ie n .SS "my $doc = read_xml($xml_location)"
.el .SS "my \f(CW$doc\fP = read_xml($xml_location)"
.IX Subsection "my $doc = read_xml($xml_location)"
This will read the \s-1XML,\s0 process it for comparison and return it. See \fIcompare()\fR
for how it is determined.
.SH "CUSTOM HANDLERS"
.IX Header "CUSTOM HANDLERS"
Internally, XML::SemanticDiff uses an event-based model somewhat reminiscent of \s-1SAX\s0 where the various 'semantic diff events'
are handed off to a separate handler class to cope with the details. For most general cases where the user only cares about 
reporting the differences between two docs, the default handler, XML::SemanticDiff::BasicHandler, will probably  
suffice. However, it is often desirable to add side-effects to the diff process (updating datastores, widget callbacks,  
etc.) and a custom handler allows you to be creative with what to do about differences between two \s-1XML\s0 documents and how
those differences are reported back to the application through the \fIcompare()\fR method.
.SH "HANDLER METHODS"
.IX Header "HANDLER METHODS"
The following is a list of handler methods that can be used for your custom diff-handler class.
.ie n .SS "init($self, $diff_obj)"
.el .SS "init($self, \f(CW$diff_obj\fP)"
.IX Subsection "init($self, $diff_obj)"
The \f(CW\*(C`init\*(C'\fR method is called immediately before the the two document HASHes are compared. The blessed XML::SemanticDiff object
is passed as the sole argument, so any values that you wish to pass from your application to your custom handler can safely
be added to the call to XML::SemanticDiff's constructor method.
.ie n .SS "rogue_element($self, $element_name, $todoc_element_properties)"
.el .SS "rogue_element($self, \f(CW$element_name\fP, \f(CW$todoc_element_properties\fP)"
.IX Subsection "rogue_element($self, $element_name, $todoc_element_properties)"
The \f(CW\*(C`rogue_element\*(C'\fR method handles those cases where a given element exists in the to-file but not in the from-file.
.ie n .SS "missing_element($self, $element_name, $fromdoc_element_properties)"
.el .SS "missing_element($self, \f(CW$element_name\fP, \f(CW$fromdoc_element_properties\fP)"
.IX Subsection "missing_element($self, $element_name, $fromdoc_element_properties)"
The \f(CW\*(C`missing_element\*(C'\fR method handles those cases where a given element exists in the from-file but not in the to-file.
.ie n .SS "element_value($self, $element, $to_element_properties, $fromdoc_element_properties)"
.el .SS "element_value($self, \f(CW$element\fP, \f(CW$to_element_properties\fP, \f(CW$fromdoc_element_properties\fP)"
.IX Subsection "element_value($self, $element, $to_element_properties, $fromdoc_element_properties)"
The \f(CW\*(C`element_value\*(C'\fR method handles those cases where the text data differs between two elements that have the same name,
namespace \s-1URI,\s0 and are at the same location in the document tree. Note that all whitespace is normalized and the text from
mixed-content elements (those containing both text and child elements mixed together) is aggregated down to a single value.
.ie n .SS "namespace_uri($self, $element, $todoc_element_properties, $fromdoc_element_properties)"
.el .SS "namespace_uri($self, \f(CW$element\fP, \f(CW$todoc_element_properties\fP, \f(CW$fromdoc_element_properties\fP)"
.IX Subsection "namespace_uri($self, $element, $todoc_element_properties, $fromdoc_element_properties)"
The \f(CW\*(C`namespace_uri\*(C'\fR method handles case where the \s-1XML\s0 namespace \s-1URI\s0 differs between a given element in the two
documents. Note that the namespace \s-1URI\s0 is checked, not the element prefixes since <foo:element/> <bar:element/> and <element/> 
are all considered equivalent as long as they are bound to the same namespace \s-1URI.\s0
.ie n .SS "rogue_attribute($self, $attr_name, $element, $todoc_element_properties)"
.el .SS "rogue_attribute($self, \f(CW$attr_name\fP, \f(CW$element\fP, \f(CW$todoc_element_properties\fP)"
.IX Subsection "rogue_attribute($self, $attr_name, $element, $todoc_element_properties)"
The \f(CW\*(C`rogue_attribute\*(C'\fR method handles those cases where an attribute exists in a given element the to-file but not in the
from-file.
.ie n .SS "missing_attribute($self, $attr_name, $element, $todoc_element_properties, $fromdoc_element_properties)"
.el .SS "missing_attribute($self, \f(CW$attr_name\fP, \f(CW$element\fP, \f(CW$todoc_element_properties\fP, \f(CW$fromdoc_element_properties\fP)"
.IX Subsection "missing_attribute($self, $attr_name, $element, $todoc_element_properties, $fromdoc_element_properties)"
The \f(CW\*(C`missing_attribute\*(C'\fR method handles those cases where an attribute exists in a given element exists in the from-file but
not in the to-file.
.ie n .SS "attribute_value($self, $attr_name, $element, $todoc_element_properties, $fromdoc_element_properties)"
.el .SS "attribute_value($self, \f(CW$attr_name\fP, \f(CW$element\fP, \f(CW$todoc_element_properties\fP, \f(CW$fromdoc_element_properties\fP)"
.IX Subsection "attribute_value($self, $attr_name, $element, $todoc_element_properties, $fromdoc_element_properties)"
The \f(CW\*(C`attribute_value\*(C'\fR method handles those cases where the value of an attribute varies between the same element in both
documents.
.ie n .SS "final($self, $diff_obj)"
.el .SS "final($self, \f(CW$diff_obj\fP)"
.IX Subsection "final($self, $diff_obj)"
The \f(CW\*(C`final\*(C'\fR method is called immediately after the two document HASHes are compared. Like the \f(CW\*(C`init\*(C'\fR handler, it is passed a
copy of the XML::SemanticDiff object as it's sole argument.
.PP
Note that if a given method is not implemented in your custom handler class, XML::SemanticDiff will not complain; but it means
that all of those events will be silently ignored. Consider yourself warned.
.SH "AUTHOR"
.IX Header "AUTHOR"
Originally by Kip Hampton, khampton@totalcinema.com .
.PP
Further Maintained by Shlomi Fish, <http://www.shlomifish.org/> .
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 Kip Hampton. All rights reserved. This program is 
free software; you can redistribute it and/or modify it under the same terms 
as Perl itself.
.PP
Shlomi Fish hereby disclaims any implicit or explicit copyrights on this
software.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under 
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
